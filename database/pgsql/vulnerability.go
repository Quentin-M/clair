package pgsql

import (
	"database/sql"

	"github.com/coreos/clair/database"
	"github.com/coreos/clair/utils"
	cerrors "github.com/coreos/clair/utils/errors"
	"github.com/coreos/clair/utils/types"
)

func (pgSQL *pgSQL) FindVulnerability(namespace database.Namespace, name string) (database.Vulnerability, error) {
	//TODO
	return database.Vulnerability{}, nil
}

func (pgSQL *pgSQL) InsertVulnerabilities(vulnerabilities []database.Vulnerability) error {
	// TODO
	return nil
}

func (pgSQL *pgSQL) insertVulnerability(vulnerability database.Vulnerability) error {
	// Verify parameters
	if vulnerability.Name == "" || len(vulnerability.FixedIn) == 0 ||
		vulnerability.Namespace.Name == "" {
		log.Warning("could not insert an invalid vulnerability")
		return cerrors.NewBadRequestError("could not insert an invalid vulnerability")
	}

	// Find or insert Vulnerability's Namespace.
	namespaceID, err := pgSQL.insertNamespace(vulnerability.Namespace)
	if err != nil {
		return err
	}

	// Find vulnerability and its Vulnerability_FixedIn_Features.
	existingVulnerability, err := pgSQL.FindVulnerability(vulnerability.Namespace, vulnerability.Name)
	if err != nil && err != cerrors.ErrNotFound {
		return err
	}

	// Compute new/updated FixedIn FeatureVersions.
	var newFixedInFeatureVersions []database.FeatureVersion
	var updatedFixedInFeatureVersions []database.FeatureVersion
	if existingVulnerability.ID == 0 {
		newFixedInFeatureVersions = vulnerability.FixedIn
	} else {
		newFixedInFeatureVersions, updatedFixedInFeatureVersions = diffFixedIn(vulnerability, existingVulnerability)
	}

	if len(newFixedInFeatureVersions) == 0 && len(updatedFixedInFeatureVersions) == 0 {
		// Nothing to do.
		return nil
	}

	// Insert or find the new FeatureVersions.
	// We already have the Feature IDs in updatedFixedInFeatureVersions because diffFixedIn fills them
	// in using the existing vulnerability's FixedIn FeatureVersions. Note that even if FixedIn
	// is type FeatureVersion, the actual stored ID in these structs are the Feature IDs.
	for i := 0; i < len(newFixedInFeatureVersions); i++ {
		newFixedInFeatureVersions[i].ID, err = pgSQL.insertFeatureVersion(newFixedInFeatureVersions[i])
		if err != nil {
			return err
		}
	}

	// Begin transaction.
	tx, err := pgSQL.Begin()
	if err != nil {
		tx.Rollback()
		return handleError("insertVulnerability.Begin()", err)
	}

	// Set transaction as SERIALIZABLE.
	// This is how we ensure that the data in Vulnerability_Affects_FeatureVersion is always
	// consistent.
	_, err = tx.Exec("SET TRANSACTION SERIALIZABLE")
	if err != nil {
		tx.Rollback()
		return handleError("insertFeatureVersion.SetTxSerializable", err)
	}

	if existingVulnerability.ID == 0 {
		// Insert new vulnerability.
		err = tx.QueryRow(getQuery("i_vulnerability"), namespaceID, vulnerability.Name,
			vulnerability.Description, vulnerability.Link, vulnerability.Severity).Scan(&vulnerability.ID)
		if err != nil {
			tx.Rollback()
			return handleError("i_vulnerability", err)
		}
	} else {
		// Update vulnerability
		_, err = tx.Exec(getQuery("u_vulnerability"), existingVulnerability.ID,
			vulnerability.Description, vulnerability.Link, vulnerability.Severity)
		if err != nil {
			tx.Rollback()
			return handleError("u_vulnerability", err)
		}

		vulnerability.ID = existingVulnerability.ID
	}

	// Update Vulnerability_FixedIn_Feature and Vulnerability_Affects_FeatureVersion now.
	err = pgSQL.updateVulnerabilityFeatureVersions(tx, &vulnerability, &existingVulnerability, newFixedInFeatureVersions, updatedFixedInFeatureVersions)
	if err != nil {
		tx.Rollback()
		return err
	}

	// Commit transaction.
	err = tx.Commit()
	if err != nil {
		tx.Rollback()
		return handleError("insertVulnerability.Commit()", err)
	}

	return nil
}

func diffFixedIn(vulnerability, existingVulnerability database.Vulnerability) (newFixedIn, updatedFixedIn []database.FeatureVersion) {
	// Build FeatureVersion.Feature.Namespace.Name:FeatureVersion.Feature.Name (NaN) structures.
	vulnerabilityFixedInMapNaN, vulnerabilityFixedInNaN := createNaN(vulnerability.FixedIn)
	existingFixedInMapNaN, existingFixedInNaN := createNaN(existingVulnerability.FixedIn)

	// Calculate the new FixedIn FeatureVersion NaN and updated ones.
	newFixedInNaN := utils.CompareStringLists(vulnerabilityFixedInNaN,
		existingFixedInNaN)
	updatedFixedInNaN := utils.CompareStringListsInBoth(vulnerabilityFixedInNaN,
		existingFixedInNaN)

	for _, nan := range newFixedInNaN {
		newFixedIn = append(newFixedIn, vulnerabilityFixedInMapNaN[nan])
	}
	for _, nan := range updatedFixedInNaN {
		fv := existingFixedInMapNaN[nan]
		fv.Version = vulnerabilityFixedInMapNaN[nan].Version
		updatedFixedIn = append(updatedFixedIn, fv)
	}

	return
}

func createNaN(features []database.FeatureVersion) (map[string]database.FeatureVersion, []string) {
	mapNaN := make(map[string]database.FeatureVersion, 0)
	sliceNaN := make([]string, 0, len(features))

	for i := 0; i < len(features); i++ {
		featureVersion := features[i]
		nv := featureVersion.Feature.Namespace.Name + ":" + featureVersion.Feature.Name
		mapNaN[nv] = featureVersion
		sliceNaN = append(sliceNaN, nv)
	}

	return mapNaN, sliceNaN
}

func (pgSQL *pgSQL) updateVulnerabilityFeatureVersions(tx *sql.Tx, vulnerability, existingVulnerability *database.Vulnerability, newFixedInFeatureVersions, updatedFixedInFeatureVersions []database.FeatureVersion) error {
	var fixedInID int

	for _, fv := range newFixedInFeatureVersions {
		// Insert Vulnerability_FixedIn_Feature.
		err := tx.QueryRow(getQuery("i_vulnerability_fixedin_feature"), vulnerability.ID, fv.ID, fv.Version).Scan(&fixedInID)
		if err != nil {
			return handleError("i_vulnerability_fixedin_feature", err)
		}

		// Insert Vulnerability_Affects_FeatureVersion.
		err = linkVulnerabilityToFeatureVersions(tx, fixedInID, vulnerability.ID, fv.ID, fv.Version)
		if err != nil {
			return err
		}
	}

	for _, fv := range updatedFixedInFeatureVersions {
		// Update Vulnerability_FixedIn_Feature.
		err := tx.QueryRow(getQuery("u_vulnerability_fixedin_feature"), vulnerability.ID, fv.ID, fv.Version).Scan(&fixedInID)
		if err != nil {
			return handleError("u_vulnerability_fixedin_feature", err)
		}

		// Drop all old Vulnerability_Affects_FeatureVersion.
		_, err = tx.Exec(getQuery("r_vulnerability_affects_featureversion"), fixedInID)
		if err != nil {
			return handleError("r_vulnerability_affects_featureversion", err)
		}

		// Insert Vulnerability_Affects_FeatureVersion.
		err = linkVulnerabilityToFeatureVersions(tx, fixedInID, vulnerability.ID, fv.ID, fv.Version)
		if err != nil {
			return err
		}
	}

	return nil
}

func linkVulnerabilityToFeatureVersions(tx *sql.Tx, fixedInID, vulnerabilityID, featureID int, fixedInVersion types.Version) error {
	// Find every FeatureVersions of the Feature we want to affect.
	// TODO(Quentin-M): LIMIT
	rows, err := tx.Query(getQuery("f_featureversion_by_feature"), featureID)
	if err != nil {
		return handleError("f_featureversion_by_feature", err)
	}
	defer rows.Close()

	var featureVersionID int
	var featureVersionVersion types.Version
	for rows.Next() {
		err := rows.Scan(&featureVersionID, &featureVersionVersion)
		if err != nil {
			return handleError("f_featureversion_by_feature.Scan()", err)
		}

		if featureVersionVersion.Compare(fixedInVersion) < 0 {
			_, err := tx.Exec("i_vulnerability_affects_featureversion", vulnerabilityID, featureVersionID, fixedInID)
			if err != nil {
				return handleError("i_vulnerability_affects_featureversion", err)
			}
		}
	}
	if err = rows.Err(); err != nil {
		return handleError("f_featureversion_by_feature.Rows()", err)
	}

	return nil
}
